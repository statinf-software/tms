/*
 *	RISC-V Instruction Set
 *
 *	This file is part of GLISS
 *	Copyright (c) 2017, IRIT UPS.
 *
 *	GLISS is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	GLISS is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with GLISS; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// DOC: page 135
op addb_AX(ax: ACC, imm: int(8))
	syntax = format("ADDB %s, #%d", ax, imm)
	image = format("1001 110%s %8b", ax, imm)
	action = { } // AX = AX + S:8bit;

// DOC: page 137
op addb_XARn(xarn: card(3), imm: card(7))
	syntax = format("ADDB XAR%d, #%d", xarn, imm)
	image = format("1101 1%3b 0%7b", xarn, imm)
	action = { } // XARn = XARn + 0:7bit;

// DOC: page 181
op cmpl_ACC_loc32(src: LOC32)
	syntax = format("CMPL ACC, %s", src.syntax)
	image = format("0000 1111 %s", src.image)
	action = { } //Modify flags on (ACC - [loc32]);

// DOC: page 220
op lcr(imm: card(22))
	syntax = format("LCR 0x%06x", imm)
	image = format("0111 0110 01 %22b", imm)
	action = {
		// [SP] = RPC(15:0);
		// SP = SP + 1;
		// [SP] = RPC(21:16);
		// SP = SP + 1;
		// RPC = PC + 2;
		// PC = 22bit;
	}

// DOC: page 229
op lretr()
	syntax = "LRETR"
	image = "0000 0000 0000 0110"
	action = {
		// UNTESTED
		PC = RPC;
		SP = SP - 1;
		TMP<31..16> = M32[SP];
		SP = SP - 1;
		TMP<15..0> = M32[SP];
		RPC = TMP<21..0>;
	}

// DOC: page 237
op lsr_AX(ax: ACC, shift: card(4))
	syntax = format("LSR %s, %d", ax, shift+1)
	image = format("1111 1111 110%s %4b", ax, shift)
	action = { } //

// DOC: page 252
op mov_16bit_loc16(imm: card(16), src: LOC16)
	syntax = format("MOV @0x%x, %s", imm, src)
	image = format("1111 0100 %s %16b", src, imm)
	action = {
		// [0x0000:16bit] = [loc16];
	}

// DOC: page 257
op mov_AX(ax: ACC, src: LOC16)
	syntax = format("MOV %s, %s", ax, src)
	image = format("1001 001%s %s", ax, src)
	action = { } // AX = [loc16];

// DOC: page 262
op mov_loc16_0(dest: LOC16)
	syntax = format("MOV %s, #0", dest.syntax)
	image = format("0010 1011 %s", dest.image)
	action = {
		// [loc16] = 0x0000;
	}

// DOC: page 264
op mov_loc16_ARn(arn: card(3), dest:LOC16)
	syntax = format("MOV %s, AR%d", dest, arn)
	image = format("0111 1%3b %s", arn, dest)
	action = { } // [loc16] = ARn;

// DOC: page 265
op mov_loc16_AX(dest: LOC16, ax: ACC)
	syntax = format("MOV %s, %s", dest, ax)
	image = format("1001 011%s %8b", ax, dest)
	action = { } // [loc16] = AX;

// DOC: page 273
op mov_ph_loc16(src: LOC16)
	syntax = format("MOV PH, %s", src.syntax)
	image = format("0010 1111 %s", src.image)
	action = {
		// PH = [loc16];
	}

// DOC: page 281
op movb_ACC(imm: card(8))
	syntax = format("MOVB ACC, #%d", imm)
	image = format("0000 0010 %8b", imm)
	action = { } // ACC = 0:8bit;

// DOC: page 283
op movb_AX(ax: ACC, imm: card(8))
	syntax = format("MOVB %s, #0x%02x", ax, imm)
	image = format("1001 101%s %8b", ax, imm)
	action = { } // AX = 0:8bit;

//this format only works for XAR0..5, 6 and 7 must be handled separately
// DOC: page 294
op movb_XARn(xarn: card(3), imm: card(8))
	syntax = format("MOVB XAR%d, #0x%02x", xarn, imm)
	image = format("1101 0%3b %8b", xarn, imm)
	action = { } //XARn = 0:8bit;
// DOC: page 294
op movb_XAR6(imm: card(8))
	syntax = format("MOVB XAR6, #0x%02x", imm)
	image = format("1011 1110 %8b", imm)
	action = { } //XAR6 = 0:8bit;
// DOC: page 294
op movb_XAR7(imm: card(8))
	syntax = format("MOVB XAR7, #0x%02x", imm)
	image = format("1011 0110 %8b", imm)
	action = { } //XAR7 = 0:8bit;

// DOC: page 298; BUG? same opcode as POP ACC page 353
op movl_ACC_loc32(src: LOC32)
	syntax = format("MOVL ACC, %s", src.syntax)
	image = format("0000 0110 %s", src.image)
	action = { } // ACC = [loc32];

// DOC: page 300; BUG? same opcode as PUSH ACC page 369
op movl_loc32_ACC(src: LOC32)
	syntax = format("MOVL %s, ACC", src.syntax)
	image = format("0001 1110 %s", src.image)
	action = { } // [loc32] = ACC;

// DOC: page 304
macro MakeMovlLoc32Xarn(xarn, fmt) = \
	syntax = format("MOVL %s, %s", dest.syntax, xarn)\
	image = format(fmt, dest.image)\
	action = { } // [loc32] = XARn;
op movl_loc32_XAR0(dest: LOC32) MakeMovlLoc32Xarn("XAR0", "0011 1010 %s")
op movl_loc32_XAR1(dest: LOC32) MakeMovlLoc32Xarn("XAR1", "1011 0010 %s")
op movl_loc32_XAR2(dest: LOC32) MakeMovlLoc32Xarn("XAR2", "1010 1010 %s")
op movl_loc32_XAR3(dest: LOC32) MakeMovlLoc32Xarn("XAR3", "1010 0010 %s")
op movl_loc32_XAR4(dest: LOC32) MakeMovlLoc32Xarn("XAR4", "1010 1000 %s")
op movl_loc32_XAR5(dest: LOC32) MakeMovlLoc32Xarn("XAR5", "1010 0000 %s")
op movl_loc32_XAR6(dest: LOC32) MakeMovlLoc32Xarn("XAR6", "1100 0010 %s")
op movl_loc32_XAR7(dest: LOC32) MakeMovlLoc32Xarn("XAR7", "1100 0011 %s")

// DOC: page 308
macro MakeMovlXarnLoc32(xarn, fmt) = \
	syntax = format("MOVL %s, %s", xarn, src.syntax)\
	image = format(fmt, src.image)\
	action = { } // XARn = [loc32];
op movl_XAR0_loc32(src: LOC32) MakeMovlXarnLoc32("XAR0", "1000 1110 %s")
op movl_XAR1_loc32(src: LOC32) MakeMovlXarnLoc32("XAR1", "1000 1011 %s")
op movl_XAR2_loc32(src: LOC32) MakeMovlXarnLoc32("XAR2", "1000 0110 %s")
op movl_XAR3_loc32(src: LOC32) MakeMovlXarnLoc32("XAR3", "1000 0010 %s")
op movl_XAR4_loc32(src: LOC32) MakeMovlXarnLoc32("XAR4", "1000 1010 %s")
op movl_XAR5_loc32(src: LOC32) MakeMovlXarnLoc32("XAR5", "1000 0011 %s")
op movl_XAR6_loc32(src: LOC32) MakeMovlXarnLoc32("XAR6", "1100 0100 %s")
op movl_XAR7_loc32(src: LOC32) MakeMovlXarnLoc32("XAR7", "1100 0101 %s")

// DOC: page 316
op movw(imm: card(16))
	syntax = format("MOVW DP, #0x%x", imm)
	image = format("0111 0110 0001 1111 %16b", imm)
	action = {
		//DP<15..0> = imm;
	}

// DOC: page 309
macro MakeMovlXarn22bit(xarn, fmt) = \
	syntax = format("MOVL %s, #0x%06x", xarn, imm)\
	image = format(fmt, imm)\
	action = { } // XARn = 0:22bit;
op movl_XAR0_22bit(imm: card(22)) MakeMovlXarn22bit("XAR0", "1000 1101 00 %22b")
op movl_XAR1_22bit(imm: card(22)) MakeMovlXarn22bit("XAR1", "1000 1101 01 %22b")
op movl_XAR2_22bit(imm: card(22)) MakeMovlXarn22bit("XAR2", "1000 1101 10 %22b")
op movl_XAR3_22bit(imm: card(22)) MakeMovlXarn22bit("XAR3", "1000 1101 11 %22b")
op movl_XAR4_22bit(imm: card(22)) MakeMovlXarn22bit("XAR4", "1000 1111 00 %22b")
op movl_XAR5_22bit(imm: card(22)) MakeMovlXarn22bit("XAR5", "1000 1111 01 %22b")
op movl_XAR6_22bit(imm: card(22)) MakeMovlXarn22bit("XAR6", "0111 0110 10 %22b")
op movl_XAR7_22bit(imm: card(22)) MakeMovlXarn22bit("XAR7", "0111 0110 11 %22b")

// DOC: page 318
op movz_ARn_0to5(xarn: card(3), src: LOC16)
	syntax = format("MOVZ AR%d, %s", xarn, src)
	image = format("0101 1%3b %s", xarn, src)
	action = { } //ARn = [loc16]; ARnH = 0;
op movz_AR6(src: LOC16)
	syntax = format("MOVZ AR6, %s", src)
	image = format("1000 1000 %s", src)
	action = { } // AR6 = [loc16]; AR6H = 0;
op movz_AR7(src: LOC16)
	syntax = format("MOVZ AR7 %s", src)
	image = format("1000 0000 %s", src)
	action = { } // AR7 = [loc16]; AR7H = 0;

// DOC: page 339
op nop(arpn: LOC32)
	syntax =
		if arpn == 0x00 then // simple NOP
			"NOP"
		else
			// UNTESTED
			format("NOP %s", arpn)
	endif
	image = format("0111 0111 %s", arpn)
	action = {
		// Modify the indirect address operand as specified and change the auxiliary register pointer (ARP) to the given auxiliary register.
		// If no operands are given, then do nothing.
	}

// DOC: page 399
op sb(off: int(8), cond: COND)
	syntax = format("SB %d, %s", off, cond.syntax)
	image = format("0110 %s %8b", cond.image, off)
	action = {
		// If (COND = true) PC = PC + signed 8-bit offset;
		// If (COND = false) PC = PC + 1;
	}

// DOC: page 420
op subb_ACC(src: card(8))
	syntax = format("SUBB ACC, #%d", src)
	image = format("0001 1001 %8b", src)
	action = { } //ACC = ACC - 0:8bit;

// DOC: page 422. catches dc02, ADDB must be implemented
op subb_XARn(xarn: card(3), imm: card(7))
	syntax = format("SUBB XAR%d, #%d", xarn, imm)
	image = format("1101 1%3b 1 %7b", xarn, imm)
	action = { } // XARn = XARn − 0:7bit;
	
// DOC: page 433
op subu(src: LOC16)
	syntax = format("SUBU ACC, %s", src)
	image = format("0000 0001 %s", src)
	action = { } //ACC = ACC − 0:[loc16];

// DOC: page 436
op tbit_loc16_4bit(src: LOC16, index: card(4))
	syntax = format("TBIT %s, #0x%x", src, index)
	image = format("0100 %4b %s", index, src)
	action = {
		// TC = [loc16(bit)];
	}


/////// UNTESTED INSTRUCTIONS /////////

// DOC: page 124
op aborti()
    syntax = "ABORTI"
    image = "0000 0000 0000 0001"
    action = {

    }

// DOC: page 125
op abs_ACC()
    syntax = "ABS ACC"
    image = "1111 1111 0101 0110"
    action = {

    }

// DOC: page 126
op abstc_ACC()
    syntax = "ABSTC ACC"
    image = "0101 0110 0101 1111"
    action = {

    }


// DOC: page 128
op add_ACC_16bit(imm: card(16), shift: card(4))
    syntax = format("ADD ACC, #%d<<#%d", imm, shift)
    image = format("1111 1111 0001 %4b %16b", shift, imm)
    action = {

    }

// DOC: page 129
// op add_ACC_loc16
//    syntax = ""
//    image = ""
//    action = {
//
//    }

// DOC: page 130
//op 
//    syntax = ""
//    image = ""
//    action = {
//
//    }

// DOC: page 131
op add_AX_loc16(ax: ACC, dest: LOC16)
    syntax = format("ADD %s, %s", ax, dest)
    image = format("1001 010%s %s", ax, dest)
    action = {

    }

// DOC: page 132
op add_loc16_AX(ax: ACC, src: LOC16)
    syntax = format("ADD %s, %s", src, ax)
    image = format("0111 001%s %s", ax, src)
    action = {

    }

// DOC: page 133
op add_loc16_signed(dest: LOC16, imm: int(16))
    syntax = format("ADD %s, #%d", dest, imm)
    image = format("0000 1000 %s %16b", dest, imm)
    action = {

    }

// DOC: page 134
op addb_ACC(imm: card(8))
    syntax = format("ADDB ACC, #%d", imm)
    image = format("0000 1001 %8b", imm)
    action = {

    }

// DOC: page 136
op addb_SP(imm: card(7))
    syntax = format("ADDB SP, #%d", imm)
    image = format("1111 1110 0%7b", imm)
    action = {
    	// SP = SP + 0:7bit;
    }

// DOC: page 138
//op addcl_ACC_loc32
//    syntax = ""
//    image = ""
//    action = {

//    }

// DOC: page 139
op addcu_ACC_loc16(src: LOC16)
    syntax = format("ADDCU ACC, %s", src)
    image = format("0000 1100 %s", src)
    action = {
    	// ACC = ACC + 0:[loc16] + C;
    }

// DOC: page 140
op addl_ACC_loc32(src: LOC32)
    syntax = format("ADDL ACC, %s", src)
    image = format("0000 0111 %s", src)
    action = {
    	//ACC = ACC + [loc32];
    }

// DOC: page 141
op addl_ACC_P()
    syntax = "ADDL ACC,P << PM"
    image = "0001 0000 1010 1100"
    action = {
    	//ACC = ACC + P << PM
    }

// DOC: page 142
op addl_loc32_ACC(dest: LOC32)
    syntax = format("ADDL %s, ACC", dest)
    image = format("0101 0110 0000 0001 0000 0000 %s", dest)
    action = {
    	//[loc32] = [loc32] + ACC;
    }

// DOC: page 143
op addu_ACC_loc16(src: LOC16)
    syntax = format("ADDU ACC, %s", src)
    image = format("0000 1101 %s", src)
    action = {
    	// ACC = ACC + 0:[loc16];
    }

// DOC: page 144
op addul_P_loc32(src: LOC32)
    syntax = format("ADDUL P, %s", src)
    image = format("0101 0110 0101 0111 0000 0000 %s", src)
    action = {
    	//P = P + [loc32]; unsigned add
    }

// DOC: page 145
//op addul_ACC_loc32(src: LOC32)
//   syntax = format("ADDUL ACC, %s", src)
//    image = format("")
//    action = {
//
//    }

// DOC: page 146
op adrk(imm: card(8))
    syntax = format("ADRK #%d", imm)
    image = format("1111 1100 %8b", imm)
    action = {
    	//XAR(ARP) = XAR(ARP) + 0:8bit;
    }

// DOC: page 147
//op and_ACC_16bit(shift: card(4), imm: card(16))
//    syntax = ""
//    image = ""
//    action = {

//    }

// DOC: page 148
op and_ACC_loc16(loc: LOC16)
    syntax = format("AND ACC, %s", loc)
    image = format("1000 1001 %s", loc)
    action = {
    	//ACC = ACC AND 0:[loc16];
    }

// DOC: page 149
op and_AX_loc16_16bit(ax: ACC, loc: LOC16, imm: card(16))
    syntax = format("AND %s, %s, #%d", ax, loc, imm)
    image = format("1100 110%s %s %16b", ax, loc, imm)
    action = {
    	//AX = [loc16] AND 16bit;
    }

// DOC: page 150
op and_IER(imm: card(16))
    syntax = format("AND IER, #%d", imm)
    image = format("0111 0110 0010 0110 %16b", imm)
    action = {
    	//IER = IER AND #16bit;
    }

// DOC: page 151
op  and_IFR(imm: card(16))
    syntax = format("AND IFR, #%d", imm)
    image = format("0111 0110 0010 1111 %16b", imm)
    action = {
    	//IFR = IFR AND #16bit;
    }

// DOC: page 152
op and_loc16_AX(ax: ACC, dest: LOC16)
    syntax = format("AND %s, %s", dest, ax)
    image = format("1100 000%s %s", ax, dest)
    action = {
    	//[loc16] = [loc16] AND AX;
    }

// DOC: page 153
op and_AX_loc16(ax: ACC, src:LOC16)
    syntax = format("AND %s, %s", ax, src)
    image = format("1100 111%s %s", ax, src)
    action = {
    	//AX = AX AND 16bit;
    }

// DOC: page 154
op and_loc16_16bitsigned(src: LOC16, imm: int(16))
    syntax = format("AND %s, #%d", src, imm)
    image = format("0001 1000 %s %16b", src, imm)
    action = {
    	//[loc16] = [loc16] AND 16bit;
    }

// DOC: page 155
op andb_AX(ax: ACC, imm: card(8))
    syntax = format("ANDB %s, #%d", ax, imm)
    image = format("1001 000%s %8b", ax, imm)
    action = {
    	//AX = AX AND 0:8bit;
    }

// DOC: page 156
op asp()
    syntax = "ASP"
    image = "0111 0110 0001 1011"
    action = {

    }

// DOC: page 157
op asr_ax(ax: ACC, shift: card(4))
    syntax = format("ASR %s, #%d", ax, shift+1)
    image = format("1111 1111 101%s %4b", ax, shift)
    action = {

    }

// DOC: page 158
op asr_ax_t(ax: ACC)
    syntax = format("ASR %s, T", ax)
    image = format("1111 1111 0110 010%s", ax)
    action = {

    }

// DOC: page 159
op asr_acc(shift: card(4))
    syntax = format("ASR64 ACC:P,#%d", shift+1)
    image = format("0101 0110 1000 %4b", shift)
    action = {

    }

// DOC: page 160
op asr_acc_t()
    syntax = "ASR64 ACC:P, T"
    image = "0101 0110 0010 1100"
    action = {

    }

// DOC: page 161
op asrl_acc_t()
    syntax = "ASRL ACC, T"
    image = "0101 0110 0001 0000"
    action = {

    }

// DOC: page 162
//op b(offset: int(16), cond: card(4))
//    syntax = format("B %d, ")
//    image = ""
//    action = {

//    }

// DOC: page 163
op banz(offset: int(16), arn: card(3)) 
    syntax = format("BANZ %d, AR%d--", offset, arn)
    image = format("0000 0000 0000 1%3b %16b", arn, offset)
    action = {

    }

// DOC: page 164
op bar(offset: int(16), arn: card(3), arm: card(3), eq: bit)
	eq_type = if eq == 0 then "EQ" else "NEQ" endif
    syntax = format("BAR %d, AR%d, AR%d, %s", offset, arn, arm, eq_type)
    image = format("1000 1111 1%1b %3b %3b %16b", eq, arn, arm, offset)
    action = {
    	//If (tested condition = true) PC = PC + signed 16-bit offset;
		//If (tested condition = false) PC = PC + 2;
    }

// DOC: page 165
//op bf(cond: card(4), offset: int(16))
//    syntax = format("BF %d, ")
//    image = ""
//    action = {

//    }

// DOC: page 166
//broken, see page 172 clrc_m0m1map
//op c27map()
//    syntax = "C27MAP"
//    image = "0101 0110 0011 1111"
//    action = {

//    }

// DOC: page 167
//broken, see page 174 CLRC Objmode
//op c27obj()
//    syntax = "C27OBJ"
//    image = "0101 0110 0011 0110"
//    action = {

//    }

// DOC: page 168
//broken, see page 171 CLRC AMODE
//op c28addr()
//    syntax = "C28ADDR"
//    image = "0101 0110 0001 0110"
//    action = {

//    }

//broken, see page 405 setc_M0M1MAP
// DOC: page 169
//op c28map()
//    syntax = "C28MAP"
//    image = "0101 0110 0001 1010"
//    action = {

//    }

// DOC: page 170
// broken, conflicts with page 406 (setc objmode)
// op c28obj()
//     syntax = "C28OBJ"
//     image = "0101 0110 0001 1111"
//     action = {

//     }

// DOC: page 171
op clrc_amode()
    syntax = "CLRC AMODE"
    image = "0101 0110 0001 0110"
    action = {

    }

// DOC: page 172
op clrc_m0m1map()
    syntax = "CLRC M0M1MAP"
    image = "0101 0110 0011 1111"
    action = {

    }

// DOC: page 173
op clrc_objmode()
    syntax = "CLRC Objmode"
    image = "0101 0110 0011 0110"
    action = {

    }

//broken, opcode conflicts with ZAP OVX (pg 471)
// // DOC: page 174
// op clrc_ovc()
//     syntax = "CLRC OVC"
//     image = "0101 0110 0101 1100"
//     action = {

//     }

// DOC: page 175
op clrc_xf()
    syntax = "CLRC XF"
    image = "0101 0110 0001 1011"
    action = {

    }

// // DOC: page 176
// op clrc_mode 
//    syntax = ""
//    image = ""
//    action = {

//    }

// DOC: page 177
op cmp_ax(ax: ACC, loc: LOC16)
    syntax = format("CMP %s, %s", ax, loc)
    image = format("0101 010%s %s", ax, loc)
    action = {
    	//Set Flags On (AX − [loc16]);
    }

// DOC: page 178
op cmp_loc16(loc: LOC16, imm: int(16))
    syntax = format("CMP %s, #%d", loc, imm)
    image = format("0001 1011 %s %16b", loc, imm)
    action = {
    	//Modify flags on ([loc16] − 16bitSigned);
    }

// DOC: page 179
op cmp64_acc_p()
    syntax = "CMP64 ACC:P"
    image = "0101 0110 0101 1110"
    action = {

    }

// DOC: page 180
op cmpb(ax: ACC, imm: card(8))
    syntax = format("CMPB %s, %d", ax, imm)
    image = format("0101 001%s %8b", ax, imm)
    action = {
    	//Set Flags On (AX − 0:8bit);
    }

// DOC: page 182
op cmpl_ACC_p()
    syntax = "CMPL ACC, P << PM"
    image = "1111 1111 0101 1001"
    action = {
    	//Modify flags on (ACC − [P << PM]);
    }

// DOC: page 183
//op cmpr
//    syntax = ""
//    image = ""
//    action = {

//    }

// DOC: page 184
op csb()
    syntax = "CSB ACC"
    image = "0101 0110 0011 0101"
    action = {

    }

// DOC: page 185
op dec(loc: LOC16)
    syntax = format("DEC %s", loc)
    image = format("0000 1011 %s", loc)
    action = {

    }

// DOC: page 186
op dint()
    syntax = "DINT"
    image = "0011 1011 0001 0000"
    action = {

    }

// DOC: page 187
op dmac(dmactype: bit, dmacmode: LOC32)
	pp = if dmactype == 0 then "*XAR7++" else "*XAR7" endif
    syntax = format("DMAC ACC:P, %s, %s", dmacmode, pp)
    image = format("0101 0110 0100 1011 1%1b00 0111 %8b", dmactype, dmacmode)
    action = {

    }

// DOC: page 189
op dmov(src: LOC16)
    syntax = format("DMOV %s", src)
    image = format("1010 0101 %s", src)
    action = {
		// loc16 + 1] = [loc16];
    }

// DOC: page 190
op eallow()
    syntax = "EALLOW"
    image = "0111 0110 0010 0010"
    action = {

    }

// DOC: page 191
op edis()
    syntax = "EDIS"
    image = "0111 0110 0001 1010"
    action = {

    }

// DOC: page 192
op eint()
    syntax = "EINT"
    image = "0010 1001 0001 0000"
    action = {

    }

// DOC: page 193
op estop0()
    syntax = "ESTOP0"
    image = "0111 0110 0010 0101"
    action = {

    }

// DOC: page 194
op estop1()
    syntax = "ESTOP1"
    image = "0111 0110 0010 0100"
    action = {

    }

// DOC: page 195
op ffc(addr: card(22))
    syntax = format("FFC XAR7, %d", addr)
    image = format ("0000 0000 11%22b", addr)
    action = {
    	//XAR7(21:0) = PC + 2;
		//XAR7(31:22) = 0;
		//PC = 22 bit;
    }

// DOC: page 196
op flip(ax: ACC)
    syntax = format("FLIP %s", ax)
    image = format("0101 0110 0111 000%s", ax)
    action = {

    }

// DOC: page 197
op iack(imm: card(16))
    syntax = format("IACK #%d", imm)
    image = format("0111 0110 0011 1111 %16b", imm)
    action = {
    	//data_bus(15:0) = 16bit;
    }

// DOC: page 198
op idle()
    syntax = "IDLE"
    image = "0111 0110 0010 0001"
    action = {

    }

// DOC: page 199
op imacl(imacmode: LOC32, imactype: bit)
	pp = if imactype == 0 then "*XAR7++" else "*XAR7" endif
    syntax = format("IMACL P, %s, %s", imacmode, pp)
    image = format("0101 0110 0100 1101 1%1b00 0111 %8b", imactype, imacmode)
    action = {

    }

// DOC: page 201
op impyal(loc: LOC32)
    syntax = format("IMPYAL P, XT, %s", loc)
    image = format("0101 0110 0100 1100 0000 0000 %8b", loc)
    action = {

    }

// DOC: page 203
op impyl_acc(loc: LOC32)
    syntax = format("IMPYL ACC, XT, %s", loc)
    image = format("0101 0110 0100 0100 0000 0000 %s", loc)
    action = {
    	//ACC = signed XT * signed [loc32];
    }

// DOC: page 204
op impyl_p(loc: LOC32)
    syntax = format("IMPYL P, XT, %s", loc)
    image = format("0101 0110 0000 0101 0000 0000 %s", loc)
    action = {

    }

// DOC: page 205
op impysl(loc: LOC32)
    syntax = format("IMPYSL P, XT, %s", loc)
    image = format("0101 0110 0100 0011 0000 0000 %s", loc)
    action = {
    	
    }

// DOC: page 207
op impyxul(loc: LOC32)
    syntax = format("IMPYXUL P, XT, %s", loc)
    image = format("0101 0110 0110 0101 0000 0000 %s", loc)
    action = {

    }

// DOC: page 209
//does the port need special formatting?
//op in(addr: LOC16, )
//   syntax = ""
//   image = ""
//   action = {

//   }

// DOC: page 211
op inc(loc: LOC16)
    syntax = format("INC %s", loc)
    image = format("0000 1010 %s", loc)
    action = {
    	//ACC = ACC + 0:[loc16];
    }

// DOC: page 212
// op intr
//     syntax = ""
//     image = ""
//     action = {

//     }

// DOC: page 214
op iret()
    syntax = "IRET"
    image = "0111 0110 0000 0010"
    action = {

    }

// DOC: page 216
op lb_xar7()
    syntax = "LB *XAR7"
    image = "0111 0110 0010 0000"
    action = {
    	//PC = XAR7(21:0);
    }

// DOC: page 217
op lb_22bit(addr: card(22))
    syntax = format("LB 0x%6x", addr)
    image = format("0000 0000 01%22b", addr)
    action = {

    }

// DOC: page 218
op lc_xar7()
    syntax = "LC *XAR7"
    image = "0111 0110 0000 0100"
    action = {

    }

// DOC: page 221
op lcr_xarn(xarn: card(3))
	syntax = format("LCR *XAR%d", xarn)
	image = format("0011 1110 0110 0%3b", xarn)
	action = { 
		//
	}
// DOC: page 222
op loopnz(addr: LOC16, imm: card(16))
	syntax = format("LOOPNZ %s, %d", addr, imm)
	image = format("0010 1110 %s %16b", addr, imm) 
	action = { 
		//while([loc16] & 16bit != 0);
	}

// DOC: page 224
op loopz(addr: LOC16, imm: card(16))
	syntax = format("LOOPZ %s, %d", addr, imm)
	image = format("0010 1100 %s %16b", addr, imm)
	action = { 
		//while([loc16] & 16bit = 0);
	}

// DOC: page 226
op lpaddr()
	syntax = "LPADDR"
	image = "0101 0110 0001 1110" 
	action = { 
		//
	}
// DOC: page 227
op lret()
	syntax = "LRET"
	image = "0111 0110 0001 0100" 
	action = { 
		//
	}
// DOC: page 228
op lrete()
	syntax = "LRETE"
	image = "0111 0110 0001 0000" 
	action = { 
		//
	}

// DOC: page 230
op lsl_ACC(shift: card(4))
	syntax = format("LSL ACC, #%d", shift+1)
	image = format("1111 1111 0011 %4b", shift)
	action = {
		//
	}
// DOC: page 231
op lsl_ACC_T()
	syntax = "LSL ACC, T"
	image = "1111 1111 0101 0000"
	action = {
		//
	}
// DOC: page 232
op lsl_AX(ax: ACC, shift: card(4))
	syntax = format("LSL %s, #%d", ax, shift+1)
	image = format("1111 1111 100%s %4b", ax, shift)
	action = {
		//
	}
// DOC: page 233
op lsl_AX_T(ax: ACC)
	syntax = format("LSL %s, T", ax)
	image = format("1111 1111 0110 011%s", ax)
	action = {
		//
	}
// DOC: page 234
op lsl64_ACC(shift: card(4))
	syntax = format("LSL64 ACC:P, #%d", shift+1)
	image = format("0101 0110 1010 %4b", shift)
	action = {
		//
	}
// DOC: page 235
op lsl64_ACC_T()
	syntax = "LSL64 ACC:P, T"
	image = "0101 0110 0101 0010"
	action = {
		//
	}
// DOC: page 236
op lsll_ACC_T()
	syntax = "LSLL ACC, T"
	image = "0101 0110 0011 1011"
	action = {
		//
	}
// DOC: page 238
op lsr_AX_T(ax: ACC)
	syntax = format("LSR %s, T", ax)
	image = format("1111 1111 0110 001%s", ax)
	action = {
		//
	}
// DOC: page 239
op lsr64_ACC(shift: card(4))
	syntax = format("LSR64 ACC:P, #%d", shift+1)
	image = format("0101 0110 1001 %4b", shift)
	action = {
		//
	}
// DOC: page 240
op lsr64_ACC_T()
	syntax = "LSR64 ACC:P, T"
	image = "0101 0110 0101 1011"
	action = {
		//
	}
// DOC: page 241
op lsrl_ACC_T()
	syntax = "LSRL ACC, T"
	image = "0101 0110 0010 0010"
	action = {
		//
	}
// DOC: page 242
// //how should this be formatted? 
// op macp_loc16(loc: LOC16, imm: card(16))
// 	syntax = format("MAC P, %s, 0:%")
// 	image = 
// 	action = {
// 		//
// 	}

// DOC: page 244

op macp_loc16_xar7(xartype: bit, loc: LOC16)
	pp = if xartype == 0 then "*XAR7++" else "*XAR7" endif
	syntax = format("MAC P, %s, %s", loc, pp)
	image = format("0101 0110 0000 0111 1%1b00 0111 %s", xartype, loc)
	action = {
		//
	}

// DOC: page 246
op max_ax(ax: ACC, loc: LOC16)
	syntax = format("MAX %s, %s", ax, loc)
	image = format("0101 0110 0111 001%s 0000 0000 %s", ax, loc)
	action = {
		//if(AX < [loc16]), AX = [loc16];
		//if(AX >= [loc16]), AX = unchanged;
	}

// DOC: page 247
op maxcul(addr: LOC32)
	syntax = format("MAXCUL P, %s", addr)
	image = format("0101 0110 0101 0001 0000 0000 %s", addr)
	action = {
		//
	}

// DOC: page 248
op maxl(addr: LOC32)
	syntax = format("MAXL ACC, %s", addr)
	image = format("0101 0110 0110 0001 0000 0000 %s", addr)
	action = {
		//
	}

// DOC: page 249
op min(ax: ACC, addr: LOC16)
	syntax = format("MIN %s, %s", ax, addr)
	image = format("0101 0110 0111 010%s 0000 0000 %s", ax, addr)
	action = {
		//
	}

// DOC: page 250
//potentially weird opcode
// op mincul(addr: LOC32)
// 	syntax =
// 	image = 
// 	action = {
// 		//
// 	}

// DOC: page 251
op minl(addr: LOC32)
	syntax = format("MINL ACC, %s", addr)
	image = format("0101 0110 0101 0000 0000 0000 %s", addr)
	action = {
		//
	}


// DOC: page 253
op mov_acc_imm(shift: card(4), imm: card(16))
	syntax = format("MOV ACC, #%d << #%d", imm, shift+1)
	image = format("1111 1111 0010 %4b %16b", shift, imm)
	action = {
		//
	}

// DOC: page 254
op mov_acc_loc16(addr: LOC16)
	syntax = format("MOV ACC, %s << T", addr)
	image = format("0101 0110 0000 0110 0000 0000 %s", addr)
	action = {
		//
	}

// DOC: page 255
// op mov_acc_loc16_shift
// 	syntax =
// 	image = 
// 	action = {
// 		//
// 	}

// DOC: page 256
//This shares an opcode with another function, but I can't work out which
// op mov_AR_loc16(arn: bit, addr: LOC16)
// 	artype = if arn == 0 then "AR6" else "AR7" endif
// 	syntax = format("MOV %s, %s", artype, addr)
// 	image = format("0101 111%1b %s", arn, addr)
// 	action = {
// 		//AR6/7 = [loc16]; AR6/7H = unchanged;
// 	}

// DOC: page 258
op mov_dp(imm: card(10))
	syntax = format("MOV DP, %d", imm)
	image = format("1111 10%10b", imm)
	action = { 

	}

// DOC: page 259
op mov_ier(src: LOC16)
	syntax = format("MOV IER, %s", src)
	image = format("0010 0011 %s", src)
	action = {
		//IER = [loc16];
	}

// DOC: page 260
op mov_loc16_const(dest: LOC16, imm:card(16))
	syntax = format("MOV %s, #%d", dest, imm)
	image = format("0010 1000 %s %16b", dest, imm)
	action = {
		//[loc16] = 16bit;
	}

// DOC: page 261
op mov_loc16_val(dest: LOC16, val: card(16))
	syntax = format("MOV %s, *(0x%x)", dest, val)
	image = format("1111 0101 %s %16b", dest, val)
	action = {
		//[loc16] = [0x0000:16bit];
	}

// // DOC: page 263
// op mov_loc16_acc()
// 	syntax =
// 	image = 
// 	action = {
// 		//
// 	}

// // DOC: page 266
// op mov_loc16_ax_cond()
// 	syntax =
// 	image = 
// 	action = {
// 		//
// 	}

// DOC: page 268
//broken, conflicts with page 436, which is in the tested section. 
//I reckon it's the other one that is too broad in its
// op mov_loc16_IER(dest: LOC16)
// 	syntax = format("MOV %s, IER", dest)
// 	image = format("0100 0000 %s", dest)
// 	action = {
// 		//[loc16] = IER;
// 	}

// DOC: page 269
op mov_loc16_ovc(dest: LOC16)
	syntax = format("MOV %s, OVC", dest)
	image = format("0101 0110 0010 1001 0000 0000 %s", dest)
	action = {
		//[loc16(15:10)] = OVC; [loc16(9:0)] = 0;
	}

// DOC: page 270
op mov_loc16_p(dest: LOC16)
	syntax = format("MOV %s, P", dest)
	image = format("0011 1111 %s", dest)
	action = {
		//[loc16] = P << PM;
	}

// DOC: page 271
op mov_loc16_T(dest: LOC16)
	syntax = format("MOV %s, T", dest)
	image = format("0010 0001 %s", dest)
	action = { 
		//[loc16] = T;
	}

// DOC: page 272
op mov_OVC_loc16(src: LOC16)
	syntax = format("MOV OVC, %s", src)
	image = format("0101 0110 0000 0010 0000 0000 %s", src)
	action = { 
		//OVC = [loc16(15:10)];
	}

// DOC: page 274
op mov_pl_loc16(src: LOC16)
	syntax = format("MOV PL, %s", src)
	image = format("0010 0111 %s", src)
	action = { 
		//PL = [loc16];
		//PH = unchanged;
	}

// DOC: page 275
op mov_pm_ax(ax: ACC)
	syntax = format("MOV PM, %s", ax)
	image = format("0101 0110 0011 100%s", ax)
	action = { 
		//PM = AX(2:0);
	}

// DOC: page 276
op mov_T_loc16(src: LOC16)
	syntax = format("MOV T, %s", src)
	image = format("0010 1101 %s", src)
	action = { 
		//T = [loc16];
	}

// DOC: page 277
op mov_TL()
	syntax = "MOV TL, #0"
	image = "0101 0110 0101 0110"
	action = { 
		//TL = 0x0000;
		//T = unchanged;
	}

// DOC: page 278
op mov_xarn_pc(xarn: card(3))
	syntax = format("MOV XAR%d, PC", xarn)
	image = format("0011 1110 0101 1%3b", xarn)
	action = { 
		//XARn = 0:PC;
	}

// DOC: page 279
//conflicts with ADDL_ACC, page 141
//op mova(src: LOC16)
//	syntax = format("MOVA T, %s", src)
//	image = format("0001 0000 %s", src)
	// action = { 
	// 	//T = [loc16];
	// 	//ACC = ACC + P << PM;
	// }

// DOC: page 280
op movad(src: LOC16)
	syntax = format("MOVAD T, %s", src)
	image = format("1010 0111 %s", src)
	action = { 
		//
	}

// DOC: page 282
// issues with movb_XARn, see page 294
// op movb_arn(arn: bit, imm: card(8))
// 	arnstr = if arn == 0 then "6" else "7" endif
// 	syntax = format("MOVB AR%s, #%d", arnstr, imm)
// 	image = format("1101 011%1b %8b", arn, imm)
// 	action = { 
// 		//
// 	}

// DOC: page 284
op movb_ax_lsb(ax: ACC, loc: LOC16)
	syntax = format("MOVB %s.LSB, %s", ax, loc)
	image = format("1100 011%s %s", ax, loc)
	action = { 
		//
	}

// DOC: page 286
op movb_ax_msb(ax: ACC, loc:LOC16)
	syntax = format("MOVB %s.MSB, %s", ax, loc)
	image = format("0011 100%s %s", ax, loc)
	action = { 
		//
	}

// // DOC: page 288
// op movb_loc16_8bit_cond
// 	syntax = 
// 	image =
// 	action = { 
// 		//
// 	}

// DOC: page 290
op movb_loc16_ax_lsb(ax: ACC, loc: LOC16)
	syntax = format("MOVB %s, %s.LSB", ax, loc)
	image = format("0011 110%s %s", ax, loc)
	action = { 
		//
	}

// DOC: page 292
op movb_loc16_ax_msb(ax: ACC, loc: LOC16)
	syntax = format("MOVB %s, %s.MSB", loc, ax)
	image = format("1100 100%s %s", ax, loc)
	action = { 
		//
	}

// DOC: page 295
op movdl_xt_loc32(src: LOC32)
	syntax = format("MOVDL XT, %s", src)
	image = format("1010 0110 %s", src)
	action = { 
		//XT = [loc32];
		//[loc32 + 2] = XT;
	}

// DOC: page 296
// op movh_loc16_acc
// 	syntax = 
// 	image =
// 	action = { 
// 		//
// 	}

// DOC: page 297
op movh_loc16_p(loc: LOC16)
	syntax = format("MOVH %s, P", loc)
	image = format("0101 0111 %s", loc)
	action = { 
		//[loc16] = (P << PM) >> 16;
	}


// DOC: page 299
op movl_acc_p()
	syntax = "MOVL ACC, P << PM"
	image = "0001 0110 1010 1100"
	action = { 
		//ACC = P << PM;
	}

// DOC: page 301
// op movl_loc32_acc_cond
// 	syntax = 
// 	image =
// 	action = { 
// 		//
// 	}

// DOC: page 303
op movl_loc32_p(dest: LOC32)
	syntax = format("MOVL %s, P", dest)
	image = format("1010 1001 %s", dest)
	action = { 
		//[loc32] = P;
	}

// // DOC: page 304
// op movl_loc32_xarn
// 	syntax = format("")
// 	image = format("")
// 	action = {
// 		//
// 	}

// DOC: page 305
//conflicts with push_xt, see page 383
// op movl_loc32_xt(dest: LOC32)
// 	syntax = format("movl %s, XT", dest)
// 	image = format("1010 1011 %s", dest)
// 	action = {
// 		//[loc32] = XT;
// 	}

// DOC: page 306
op movl_p_ACC()
	syntax = "MOVL P, ACC"
	image = "1111 1111 0101 1010"
	action = {
		//P = ACC;
	}

// DOC: page 307
op movl_p_loc32(src: LOC32)
	syntax = format("MOVL P, %s", src)
	image = format("1010 0011 %s", src)
	action = {
		//P = [loc32];
	}

// // DOC: page 310
// conflicts with pop xt, page 367
// op movl_xt_loc32(src: LOC32)
// 	syntax = format("MOVL XT, %s", src)
// 	image = format("1000 0111 %s", src)
// 	action = {
// 		//XT = [loc32];
// 	}

// // DOC: page 311
//conflicts with movl_acc_p, see page 299
// op movp(src: LOC16)
// 	syntax = format("MOVP T, %s", src)
// 	image = format("0001 0110 %s", src)
// 	action = {
// 		//T = [loc16];
// 		//ACC = P << PM;
// 	}

// DOC: page 312
op movs(src: LOC16)
	syntax = format("MOVS T, %s", src)
	image = format("0001 0001 %s", src)
	action = {
		//T = [loc16];
		//ACC = ACC − P << PM;
	}

// DOC: page 313
op movu_acc_loc16(src: LOC16)
	syntax = format("MOVU ACC, %s", src)
	image = format("0000 1110 %s", src)
	action = {
		//AL = [loc16];
		//AH = 0x0000;
	}

// DOC: page 314
op movu_loc16_OVC(dest: LOC16)
	syntax = format("MOVU %s, OVC", dest)
	image = format("0101 0110 0010 1000 0000 0000 %s", dest)
	action = {
		//[loc16(15:6)] = 0;
		//[loc16(5:0)] = OVC;
	}

// DOC: page 315
op movu_OVC_loc16(src: LOC16)
	syntax = format("MOVU OVC, %s", src)
	image = format("0101 0110 0110 0010 0000 0000 %s", src)
	action = {
		//OVC = [loc16(5:0)]
	}


// DOC: page 317
// op movx()
// 	syntax = format()
// 	image = format()
// 	action = {
// 		//
// 	}

// DOC: page 319
op movz_dp(imm: card(10))
	syntax = format("MOVZ DP, #%d", imm)
	image = format("1011 10%10b", imm)
	action = {
		//DP(9:0) = 10bit;
		//DP(15:10) = 0;
	}

// DOC: page 320
op mpy_ACC(loc: LOC16, imm:card(16))
	syntax = format("MPY ACC, %s, #%d", loc, imm)
	image = format("0011 0100 %s %16b", loc, imm)
	action = {
		//T = [loc16];
		//ACC = signed T * signed 16bit;
	}

// DOC: page 321
op mpy_ACC_T(loc: LOC16)
	syntax = format("MPY ACC, T, %s", loc)
	image = format("0001 0010 %s", loc)
	action = {
		//ACC = signed T * signed [loc16];
	}

// DOC: page 322
op mpy_P(loc: LOC16, imm: card(16))
	syntax = format("MPY P, %s, #%d", loc, imm)
	image = format("1000 1100 %s %16b", loc, imm)
	action = {
		//P = signed [loc16] * signed 16bit;
	}

// DOC: page 323
op mpy_P_T(loc: LOC16)
	syntax = format("MPY P, T, %s", loc)
	image = format("0011 0011 %s", loc)
	action = {
		//P = signed T * signed [loc16];
	}

// DOC: page 324
op mpya_P(loc: LOC16, imm: card(16))
	syntax = format("MPYA P, %s, #%d", loc, imm)
	image = format("0001 0101 %s %16b", loc, imm)
	action = {
		//ACC = ACC + P << PM;
		//T = [loc16];
		//P = signed T * signed 16bit;
	}

// DOC: page 325
op mpya_P_T(loc: LOC16)
	syntax = format("MPYA P, T, %s", loc)
	image = format("0001 0111 %s", loc)
	action = {
		//ACC = ACC + P << PM;
		//P = signed T * signed [loc16];
	}

// DOC: page 326
op mpyb_ACC(imm: card(8))
	syntax = format("MPYB ACC, T, #%d", imm)
	image = format("0011 0101 %8b", imm)
	action = {
		//ACC = signed T * 0:8bit
	}

// DOC: page 327
op mpyb_P(imm: card(8))
	syntax = format("MPYB P, T, %d", imm)
	image = format("0011 0001 %8b", imm)
	action = {
		//P = signed T * 0:8bit;
	}

// DOC: page 328
op mpys_P(loc: LOC16)
	syntax = format("MPYS P, T, %s", loc)
	image = format("0001 0011 %8b", loc)
	action = {
		//
	}

// DOC: page 329
op mpyu_p(loc: LOC16)
	syntax = format("MPYU P, T, %s", loc)
	image = format("0011 0111 %s", loc)
	action = {
		//P = unsigned T * unsigned [loc16];
	}

// DOC: page 330
op mpyu_ACC(loc: LOC16)
	syntax = format("MPYU ACC, T, %s", loc)
	image = format("0011 0110 %s", loc)
	action = {
		//ACC = unsigned T * unsigned [loc16];
	}

// DOC: page 331
op mpyxu_ACC(loc: LOC16)
	syntax = format("MPYXU ACC, T, %s", loc)
	image = format("0011 0000 %s", loc)
	action = {
		//ACC = signed T * unsigned [loc16];
	}

// DOC: page 332
op mpyxu_P(loc: LOC16)
	syntax = format("MPYXU P, T, %s", loc)
	image = format("0011 0010 %s", loc)
	action = {
		//P = signed T * unsigned [loc16];
	}

// DOC: page 333
op nasp()
	syntax = "NASP"
	image = "0111 0110 0001 0111"
	action = {
		//
	}

// DOC: page 334
op neg_ACC()
	syntax = "NEG ACC"
	image = "1111 1111 0101 0100"
	action = {
		//
	}

// DOC: page 335
op neg_ax(ax: ACC)
	syntax = format("NEG %s", ax)
	image = format("1111 1111 0101 110%s", ax)
	action = {
		//
	}

// DOC: page 336
op neg64_ax()
	syntax = "NEG64 ACC:P"
	image = "0101 0110 0101 1000"
	action = {
		//
	}

// DOC: page 337
op negtc_acc()
	syntax = "NEGTC ACC"
	image = "0101 0110 0011 0010"
	action = {
		//
	}

// DOC: page 340
op norm_ACC_ind1()
	syntax = "NORM ACC, *"
	image = "0101 0110 0010 0100"
	action = { }
op norm_ACC_ind2()
	syntax = "NORM ACC, *++"
	image = "0101 0110 0101 1010"
	action = { }
op norm_ACC_ind3()
	syntax = "NORM ACC, *- -"
	image = "0101 0110 0010 0000"
	action = { }
op norm_ACC_ind4()
	syntax = "NORM ACC, *0++"
	image = "0101 0110 0111 0111"
	action = { }
op norm_ACC_ind5()
	syntax = "NORM ACC, *0- -"
	image = "0101 0110 0011 0000"
	action = { }

// DOC: page 341
op norm_ACC_XARn(xarn: card(3), operator: bit)
	operator_str = if operator == 1 then "++" else "--" endif
	syntax = format("NORM, ACC, XAR%d%s", xarn, operator_str)
	image = format("1111 1111 0111 %1b%3b", operator, xarn)
	action = { }

// DOC: page 342
op not_acc()
	syntax = "NOT ACC"
	image = "1111 1111 0101 0101"
	action = { }

// DOC: page 343
op not_ax(ax: ACC)
	syntax = format("NOT %s", ax)
	image = format("1111 1111 0101 111%s", ax)
	action = { }
	
// DOC: page 344
op or_acc_loc16(src: LOC16)
	syntax = format("OR ACC, %s", src)
	image = format("1010 1111 %s", src)
	action = { }

// DOC: page 345
op or_acc_16bit_0_15(imm: card(16), shift: card(4))
	syntax = format("OR ACC, #0x%x << #%d", imm, shift)
	image  = format("0011 1110 0001 %4b %16b", shift, imm)
	action = {
		// ACC = ACC OR (0:16bit << shift value);
	}
// DOC: page 345
op or_acc_16bit_16(imm: card(16))
	syntax = format("OR ACC, #0x%x << #16", imm)
	image  = format("0101 0110 0100 1010 %16b", imm)
	action = {
		// ACC = ACC OR (0:16bit << 16);
	}

// DOC: page 346
op or_ax_loc16(ax: ACC, src: LOC16)
	syntax = format("OR %s, %s", ax, src)
	image  = format("1100 101%s %s", ax, src)
	action = {
		// AX = AX OR [loc16];
	}

// DOC: page 347
op or_ier_16bit(imm: card(16))
	syntax = format("OR IER, #%d", imm)
	image  = format("0111 0110 0010 0011 %16b", imm)
	action = {
		// IER = IER OR #16bit;
	}

// DOC: page 348
op or_ifr_16bit(imm: card(16))
	syntax = format("OR IFR, #%d", imm)
	image  = format("0111 0110 0010 0111 %16b", imm)
	action = {
		// IFR = IFR OR #16bit;
	}

// DOC: page 349
op or_loc16_16bit(dest: LOC16, imm: card(16))
	syntax = format("OR %s, #%d", dest, imm)
	image  = format("0001 1010 %s %16b", dest, imm)
	action = {
		// [loc16] = [loc16] OR 16bit;
	}

// DOC: page 350
op or_loc16_ax(dest: LOC16, ax: ACC)
	syntax = format("OR %s, %s", dest, ax)
	image  = format("1001 100%s %s", ax ,dest)
	action = {
		// [loc16] = [loc16] OR AX;
	}

// DOC: page 351
op orb_ax_8bit(ax: ACC, imm: card(8))
	syntax = format("ORB %s, #%d", ax, imm)
	image  = format("0101 000%s %8b", ax, imm)
	action = {
		// AX = AX OR 0x00:8bit;
	}

// DOC: page 352
op out_pa_loc16(src: LOC16, addr: card(16))
	syntax = format("OUT *(0x%04x), %s", addr, src)
	image  = format("1011 1100 %s %16b", src, addr)
	action = {
		// IOspace[0x0000PA] = [loc16];
	}

// DOC: page 353
// op pop_acc()
// 	syntax = "POP ACC"
// 	image = "0000 0110 1011 1110"
// 	action = {
// 		// SP −= 2;
// 		// ACC = [SP];
// }

// DOC: page 354
// op pop_arn_arm
// 	syntax =
// 	image =
// 	action = { }

// DOC: page 355
op pop_ar1h_ar0h()
	syntax = "POP AR1H:AR0H"
	image = "0000 0000 0000 0011"
	action = {
		// SP
		// −= 2; AR0H
		// = [SP]; AR1H =
		// [SP+1];
		// AR1:AR0 = unchanged;
	}

// DOC: page 356
op pop_dbgier()
	syntax = "POP DBGIER"
	image = "0111 0110 0001 0010"
	action = {
		// SP −= 1;
		// DBGIER = [SP];
	}

// DOC: page 357
op pop_dp()
	syntax = "POP DP"
	image = "0111 0110 0000 0011"
	action = { 
		// SP −= 1;
		// DP = [SP];
	}

// DOC: page 358
op pop_dp_st1()
	syntax = "POP DP:ST1"
	image = "0111 0110 0000 0001"
	action = {
		// SP −= 2;
		// ST1 = [SP];
		// DP = [SP+1];
	}

// DOC: page 359
op pop_ifr()
	syntax = "POP IFR"
	image = "0000 0000 0000 0010"
	action = {
		// SP −= 1;
		// IFR = [SP];
	}

// DOC: page 360
op pop_loc16(src: LOC16)
	syntax = format("POP %s", src)
	image = format("0010 1010 %s", src)
	action = {
		// SP -= 1;
		// [loc16] = [SP];
	}

// DOC: page 361
op pop_p()
	syntax = "POP P"
	image = "0111 0110 0001 0001"
	action = {
		// SP −= 2;
		// P = [SP];
	}

// DOC: page 362
op pop_rpc()
	syntax = "POP RPC"
	image = "0000 0000 0000 0111"
	action = {
		// SP −= 2;
		// RPC = [SP];
	}

// DOC: page 363
op pop_st0()
	syntax = "POP ST0"
	image = "0111 0110 0001 0011"
	action = {
		// SP −= 1;
		// ST0 = [SP];
	}

// DOC: page 364
op pop_st1()
	syntax = "POP ST1"
	image = "0111 0110 0000 0000"
	action = {
		// SP −= 1;
		// ST1 = [SP];
	}

// DOC: page 365
op pop_t_st0()
	syntax = "POP T:ST0"
	image = "0111 0110 0001 0101"
	action = {
		// SP −= 2;
		// T = [SP];
		// ST0 = [SP+1];
		// TL = unchanged;
	}

// DOC: page 366; BUG??
// macro MakePopXarn(xarn, fmt) = \
// 	syntax = format("POP %s", xarn)\
// 	image = fmt\
// 	action = {\
// 		// SP −= 2;\
// 		// XARn = [SP];\
// 	}
// op pop_XAR0() MakePopXarn("XAR0", "1000 1110 1011 1110")
// op pop_XAR1() MakePopXarn("XAR1", "1000 1011 1011 1110")
// op pop_XAR2() MakePopXarn("XAR2", "1000 0110 1011 1110")
// op pop_XAR3() MakePopXarn("XAR3", "1000 0010 1011 1110")
// op pop_XAR4() MakePopXarn("XAR4", "1000 1010 1011 1110")
// op pop_XAR5() MakePopXarn("XAR5", "1000 0011 1011 1110")
// op pop_XAR6() MakePopXarn("XAR6", "1100 0100 1011 1110")
// op pop_XAR7() MakePopXarn("XAR7", "1100 0101 1011 1110")

// DOC: page 367
op pop_xt()
	syntax = "POP XT"
	image = "1000 0111 1011 1110"
	action = {
		// SP −= 2;
		// XT = [SP];
	}

// DOC: page 368
op pread_loc16_xar7(dest: LOC16)
	syntax = format("PREAD %s, *XAR7", dest)
	image = format("0010 0100 %s", dest)
	action = {
		// [loc16] = Prog[*XAR7];
	}

// DOC: page 369; BUG?? same opcode as page 300!
// op push_acc()
// 	syntax = "PUSH ACC"
// 	image = "0001 1110 1011 1101"
// 	action = {
// 		// [SP] = ACC;
// 		// SP += 2;
// 	}

// DOC: page 370
// op push_arn_arm
// 	syntax = 
// 	image = 
// 	action = {

// 	}

// DOC: page 371
op push_ar1h_ar0h()
	syntax = "PUSH AR1H:AR0H"
	image = "0000 0000 0000 0101"
	action = {
		// [SP] = AR0H;
		// [SP+1] = AR1H;
		// SP += 2;
	}

// DOC: page 372
op push_dbgier()
	syntax = "PUSH DBGIER"
	image = "0111 0110 0000 1110"
	action = {
		// [SP] = DBGIER;
		// SP += 1;
	}

// DOC: page 373
op push_dp()
	syntax = "PUSH DP"
	image = "0111 0110 0000 1011"
	action = {
		// [SP] = DP;
		// SP += 1;
	}

// DOC: page 374
op push_dp_st1()
	syntax = "PUSH DP:ST1"
	image = "0111 0110 0000 1001"
	action = {
		// [SP] = ST1;
		// [SP+1] = DP;
		// SP += 2;
	}

// DOC: page 375
op push_ifr()
	syntax = "PUSH IFR"
	image = "0111 0110 0000 1010"
	action = {
		// [SP] = IFR;
		// SP += 1;
	}

// DOC: page 376
op push_loc16(src: LOC16)
	syntax = format("PUSH %s", src)
	image = format("0010 0010 %s", src)
	action = {
		// [SP] = [loc16];
		// SP += 1;
	}

// DOC: page 377
op push_p()
	syntax = "PUSH P"
	image = "0111 0110 0001 1101"
	action = {
		// [SP] = P;
		// SP += 2;
	}

// DOC: page 378
op push_rpc()
	syntax = "PUSH RPC"
	image = "0000 0000 0000 0100"
	action = {
		// [SP] = RPC;
		// SP += 2;
	}

// DOC: page 379
op push_st0()
	syntax = "PUSH ST0"
	image = "0111 0110 0001 1000"
	action = {
		// [SP] = ST0;
		// SP += 1;
	}

// DOC: page 380
op push_st1()
	syntax = "PUSH ST1"
	image = "0111 0110 0000 1000"
	action = {
		// [SP] = ST1;
		// SP += 1;
	}

// DOC: page 381
op push_t_st0()
	syntax = "PUSH T:ST0"
	image = "0111 0110 0001 1001"
	action = {
		// [SP] = ST0;
		// [SP+1] = T;
		// SP += 2;
	}

// DOC: page 382
// op 
// 	syntax = "PUSH XARn"
// 	image = 
// 	action = {

// 	}

// DOC: page 383
op push_xt()
	syntax = "PUSH XT"
	image = "1010 1011 1011 1101"
	action = {
		// [SP] = XT;
		// SP += 2;
	}

// DOC: page 384
op pwrite_xar7(src: LOC16)
	syntax = format("PWRITE *XAR7, %s", src)
	image = format("0010 0110 %s", src)
	action = {

	}

// DOC: page 385
// op 
// 	syntax = 
// 	image = 
// 	action = {

// 	}

// DOC: page 387
op qmpyal_p_xt_loc32(src: LOC32)
	syntax = format("QMPYAL P, XT, %s", src)
	image = format("0101 0110 0100 0110 0000 0000 %s", src)
	action = {
		// ACC = ACC + P << PM;
		// P = (signed T * signed [loc32]) >> 32;
	}

// DOC: page 388
op qmpyl_p(src: LOC32)
	syntax = format("QMPYL P, XT, %s", src)
	image = format("0101 0110 0110 0111 0000 0000 %s", src)
	action = {
		// P = (signed XT * signed [loc32]) >> 32;
	}

// DOC: page 389
op qmpyl_acc(src: LOC32)
	syntax = format("QMPYL ACC, XT, %s", src)
	image = format("0101 0110 0110 0011 0000 0000 %s", src)
	action = {
		// ACC = (signed XT * signed [loc32]) >> 32;
	}

// DOC: page 390
op qmpysl(src: LOC32)
	syntax = format("QMPYSL P, XT, %s", src)
	image = format("0101 0110 0100 0101 0000 0000 %s", src)
	action = {
		// ACC = ACC − P << PM;
		// P = (signed T * signed [loc32]) >> 32;
	}

// DOC: page 391
op qmpyul(src: LOC32)
	syntax = format("QMPYUL P, XT, %s", src)
	image = format("0101 0110 0100 0111 0000 0000 %s", src)
	action = {
		// P = (unsigned XT * unsigned [loc32]) >> 32;
	}

// DOC: page 392
op qmpyxul(src: LOC32)
	syntax = format("QMPYXUL P, XT, %s", src)
	image = format("0101 0110 0100 0010 0000 0000 %s", src)
	action = {
		// P = (signed XT * unsigned [loc32]) >> 32;
	}

// DOC: page 393
op rol_acc()
	syntax = "ROL ACC"
	image = "1111 1111 0101 0011"
	action = {

	}

// DOC: page 394
op ror_acc()
	syntax = "ROR ACC"
	image = "1111 1111 0101 0010"
	action = {

	}

// DOC: page 395
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 396
op sat_acc()
	syntax = "SAT ACC"
	image = "1111 1111 0101 0111"
	action = {

	}

// DOC: page 397
op sat64()
	syntax = "SAT64 ACC:P"
	image = "0101 0110 0011 1110"
	action = {

	}

// DOC: page 400
op sbbu(src: LOC16)
	syntax = format("SBBU ACC, %s", src)
	image = format("0001 1101 %s", src)
	action = {
		// ACC = ACC − 0:[loc16] − ~C;
	}

// DOC: page 401
// op 
// 	syntax = "SBF 8bitOffset, EQ/NEQ/TC/NTC"
// 	image = ""
// 	action = {

// 	}

// DOC: page 402
op sbrk_8bit(imm: card(8))
	syntax = format("SBRK #%d", imm)
	image = format("1111 1101 %8b", imm)
	action = {
		// XAR(ARP) = XAR(ARP) − 0:8bit;
	}

// DOC: page 403
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 405
op setc_M0M1MAP()
	syntax = "SETC M0M1MAP"
	image = "0101 0110 0001 1010"
	action = {

	}

// DOC: page 406
op setc_objmode()
	syntax = "SETC Objmode"
	image = "0101 0110 0001 1111"
	action = {
		// Set the Objmode status bit, putting the device in C28x object mode (supports C2XLP source).
	}

// DOC: page 407
op setc_xf()
	syntax = "SETC XF"
	image = "0101 0110 0010 0110"
	action = {
		// Set the XF status bit and pull the corresponding output signal high.
	}

// DOC: page 408
op sfr_acc(shift: card(4))
	syntax = format("SFR ACC, %d", shift+1)
	image = format("1111 1111 0100 %4b", shift)
	action = {
		// if(SXM = 1) // sign extension mode enabled
		// ACC = S:ACC >> shift value; // arithmetic shift right
		// else //sign extension mode disabled
		// ACC = 0:ACC >> shift value;// logical shift right
	}

// // DOC: page 409
// op 
// 	syntax = "SFR ACC, T"
// 	image = "1111 1111 0101 0001"
// 	action = {

// 	}

// // DOC: page 410
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 412
op sqra(src: LOC16)
	syntax = format("SQRA %s", src)
	image = format("0101 0110 0001 0101 0000 0000 %s", src)
	action = {
		// ACC = ACC + P << PM;
		// T = [loc16];
		// P = T * [loc16];
	}

// DOC: page 413
op sqrs(src: LOC16)
	syntax = format("SQRS %s", src)
	image = format("0101 0110 0001 0001 xxxx xxxx %s", src)
	action = {
		// ACC = ACC − P << PM;
		// T = [loc16];
		// P = T * [loc16];
	}

// // DOC: page 414
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// // DOC: page 416
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// // DOC: page 417
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 418
op sub_ax_loc16(ax: ACC, src: LOC16)
	syntax = format("SUB %s, %s", ax, src)
	image = format("1001 111%s %s", ax, src)
	action = {
		// AX = AX − [loc16];
	}

// DOC: page 419
op sub_loc16_ax(ax: ACC, src: LOC16)
	syntax = format("SUB %s, %s", src, ax)
	image = format("0111 010%s %s", ax, src)
	action = {
		// [loc16] = [loc16] − AX;
	}

// DOC: page 421
op subb_sp_7bit(imm: card(7))
	syntax = format("SUBB SP, #%d", imm)
	image = format("1111 1110 1%7b", imm)
	action = {
		// SP = SP − 0:7bit;
	}

// DOC: page 423
op subbl_acc_loc32(src: LOC32)
	syntax = format("SUBBL ACC, %s", src)
	image = format("0101 0110 0101 0100 0000 0000 %s", src)
	action = {
		// ACC = ACC − [loc32] − ~C;
	}

// DOC: page 424
op subcu_acc_loc16(src: LOC16)
	syntax = format("SUBCU ACC, %s", src)
	image = format("0001 1111 %s", src)
	action = {
		// temp(32:0) = ACC << 1 − [loc16] << 16
		// if( temp(32:0) > 0 )
		// ACC = temp(31:0) + 1
		// else
		// ACC = ACC << 1
	}

// DOC: page 426
op subcul_acc_loc32(src: LOC32)
	syntax = format("SUBCUL ACC, %s", src)
	image = format("0101 0110 0001 0111 0000 0000 %s", src)
	action = {
		// temp(32:0) = ACC << 1 + P(31) − [loc32];
		// if( temp(32:0) >= if( temp(32:0) >= 0 )
		// ACC = temp(31:0);
		// P = (P << 1) + 1;
		// else
		// ACC:P = ACC:P << 1;
	}

// DOC: page 428
op subl_acc_loc32(src: LOC32)
	syntax = format("SUBL ACC, %s", src)
	image = format("0000 0011 %s", src)
	action = {
		// ACC = ACC − [loc32];
	}

// // DOC: page 429
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 430
op subl_loc32_acc(dest: LOC32)
	syntax = format("SUBL %s, ACC", dest)
	image = format("0101 0110 0100 0001 0000 0000 %s", dest)
	action = {
		// [loc32] = [loc32] − ACC;
	}

// DOC: page 431
op subr_loc16_ax(dest: LOC16, ax: ACC)
	syntax = format("SUBR %s, %s", dest, ax)
	image = format("1110 101%s %s", ax, dest)
	action = {
		// [loc16] = AX − [loc16]
	}

// DOC: page 432
op subrl_loc32_acc(dest: LOC32)
	syntax = format("SUBRL %s, ACC", dest)
	image = format("0101 0110 0100 1001 0000 0000 %s", dest)
	action = {
		// [loc32] = ACC − [loc32];
	}

// DOC: page 434
op subul_acc_loc32(src: LOC32)
	syntax = format("SUBUL ACC, %s", src)
	image = format("0101 0110 0101 0101 0000 0000 %s", src)
	action = {
		// ACC = ACC − [loc32]; // unsigned subtraction
	}

// DOC: page 435
op subul_p_loc32(src: LOC32)
	syntax = format("SUBUL P, %s", src)
	image = format("0101 0110 0101 1101 0000 0000 %s", src)
	action = {
		// P = P − [loc32]; // unsigned subtract
	}

// DOC: page 437
op tbit_loc16_t(src: LOC16)
	syntax = format("TBIT %s, T", src)
	image = format("0101 0110 0010 0101 0000 0000 %s", src)
	action = {
		// bit = 15 − T(3:0);
		// TC = [loc16(bit)];
	}

// DOC: page 438
op tclr(dest: LOC16, imm: card(4))
	syntax = format("TCLR %s, #%d", dest, imm)
	image = format("0101 0110 0000 1001 0000 %4b %s", imm, dest)
	action = {
		// TC = [loc16(bit)];
		// [loc16(bit)] = 0;
	}

// DOC: page 439
op test_acc()
	syntax = "TEST ACC"
	image = "1111 1111 0101 1000"
	action = {
		// Modify flags on (ACC − 0x00000000);
	}

// DOC: page 440
// op 
// 	syntax = "TRAP #VectorNumber"
// 	image = "0000 0000 001C CCCC"
// 	action = {

// 	}

// DOC: page 442; BUG?!!!
// op tset_loc16_16bit(dest: LOC16, imm: card(16))
// 	syntax = format("TSET %s, #%d", dest, imm)
// 	image = format("0101 0110 0000 1101 0000 BBBB LLLL LLLL", ???)
// 	action = {
// 		// TC = [loc16(bit)];
// 		// [loc16(bit)] = 1;
// 	}

// DOC: page 443
// op 
// 	syntax = "UOUT *(PA),loc16"
// 	image = "1011 0000 LLLL LLLL CCCC CCCC CCCC CCCC"
// 	action = {
// 		// IOspace[0x000:PA] = loc16;
// 	}

// DOC: page 444
op xb_al()
	syntax = "XB *AL"
	image = "0101 0110 0001 0100"
	action = {
		// PC = 0x3F:AL;
	}

// DOC: page 445
// op 
// 	syntax = "XB pma,*, ARPn"
// 	image = "0011 1110 0111 0nnn CCCC CCCC CCCC CCCC"
// 	action = {
// 		// PC = 0x3F:pma;
// 		// ARP = n;
// 	}

// DOC: page 446
// op 
// 	syntax = "XB pma,COND"
// 	image = "0101 0110 1101 COND CCCC CCCC CCCC CCCC"
// 	action = {
// 		// If (COND = true) PC(15:0) = pma;
// 		// If (COND = false) PC(15:0) = PC(15:0) + 2;
// 		// PC(21:16) = 0x3F;
// 	}

// DOC: page 448
// op 
// 	syntax = "XBANZ pma,*ind{,ARPn}"
// 	image = ""
// 	action = {

// 	}

// DOC: page 450
op xcall_al()
	syntax = "XCALL *AL"
	image = "0101 0110 0011 0100"
	action = {
		// temp(21:0) = PC + 1;
		// [SP] = temp(15:0);
		// SP = SP + 1;
		// C = 0x3F:AL;
	}

// DOC: page 451
// op 
// 	syntax = "XCALL pma,*,ARPn"
// 	image = "0011 1110 0110 1nnn CCCC CCCC CCCC CCCC"
// 	action = {

// 	}

// // DOC: page 452
// op 
// 	syntax = "XCALL pma,COND"
// 	image = "0101 0110 1110 COND CCCC CCCC CCCC CCCC"
// 	action = {
// 		// if(COND = true)
// 		// {
// 		// temp(21:0) = PC + 2;
// 		// [SP] = temp(15:0);
// 		// SP = SP + 1;
// 		// PC
// 		// = 0x3F:pma;
// 		// }
// 		// else
// 		// PC = PC + 2;
// 	}

// // DOC: page 454
// op 
// 	syntax = "XMAC P,loc16,*(pma)"
// 	image = "1000 0100 LLLL LLLL CCCC CCCC CCCC CCCC"
// 	action = {
// 		// ACC = ACC + P << PM;
// 		// T = [loc16];
// 		// P = signed T * signed Prog[0x3F:pma];
// 	}

// // DOC: page 456
// op 
// 	syntax = "XMACD P, loc16, *(pma)"
// 	image = "1010 0100 LLLL LLLL CCCC CCCC CCCC CCCC"
// 	action = {
// 		// ACC = ACC + P << PM;
// 		// T = [loc16];
// 		// P = signed T * signed Prog[0x3F:pma];
// 		// [loc16 + 1] = T;
// 	}

// DOC: page 458
op xor_acc_loc16(src: LOC16)
	syntax = format("XOR ACC, %s", src)
	image = format("1011 0111 %s", src)
	action = {
		// 1011 0111 LLLL LLLL
	}

// // DOC: page 459
// op 
// 	syntax = ""
// 	image = ""
// 	action = {

// 	}

// DOC: page 460
op xor_ax_loc16(src: LOC16, ax: ACC)
	syntax = format("XOR %s, %s", ax, src)
	image = format("0111 000%s %s", ax, src)
	action = {
		// AX = AX XOR [loc16];
	}

// DOC: page 461
op xor_loc16_ax(dest: LOC16, ax: ACC)
	syntax = format("XOR %s, %s", dest, ax)
	image = format("1111 001%s %s", ax, dest)
	action = {
		// [loc16] = [loc16] XOR AX;
	}

// DOC: page 462
op xor_loc16_16bit(dest: LOC16, imm: card(16))
	syntax = format("XOR %s, #%d", dest, imm)
	image = format("0001 1100 %s %16b", dest, imm)
	action = {
		// [loc16] = [loc16] XOR 16bit;
	}

// DOC: page 463
op xorb(ax: ACC, imm: card(8))
	syntax = format("XORB %s, #%d", ax, imm)
	image = format("1111 000%s %8b", ax, imm)
	action = {
		// AX = AX XOR 0x00:8bit;
	}

// DOC: page 464; BUG? WRONG DESCRIPTION? NEEDS TESTING
// op xpread_loc16_pma()
// 	syntax = format("XPREAD loc16, *(pma)")
// 	image = format("1010 1100 MMMM MMM LLLL LLLL LLLL LLLL")
// 	action = {
// 		// [loc16] = Prog[0x3F:pma];
// 	}

// DOC: page 465
op xpread_loc16_al(dest: LOC16)
	syntax = format("XPREAD %s, *AL", dest)
	image = format("0101 0110 0011 1100 0000 0000 %s", dest)
	action = {
		// [loc16] = Prog[0x3F:AL];
	}

// DOC: page 466
op xpwrite(src: LOC16)
	syntax = format("XPWRITE *A, %s", src)
	image = format("0101 0110 0011 1101 0000 0000 %s", src)
	action = {
		// Prog[0x3F:AL] = [loc16];
	}

// DOC: page 467
op xret()
	syntax = "XRET"
	image = "0101 0110 1111 1111"
	action = {
		// if(COND = true)
		// SP = SP − 1;
		// PC = 0x3F:[SP];
	}

// DOC: page 468; BUG??
// op xretc_cond(c: COND)
// 	syntax = format("XRETC %s", c)
// 	image = format("0101 0110 1111 %s", c)
// 	action = {
// 		// if(COND = true)
// 		// {
// 		// SP = SP − 1;
// 		// PC = 0x3F:[SP];
// 		// }
// 		// else
// 		// PC = PC + 1;
// 	}

// DOC: page 470
op zalr(src: LOC16)
	syntax = format("ZALR ACC, %s", src)
	image = format("0101 0110 0001 0011 0000 0000 %s", src)
	action = {
		// AH = [loc16];
		// AL = 0x8000;
	}

// DOC: page 471
op zap_ovc()
	syntax = "ZAP OVC"
	image = "0101 0110 0101 1100"
	action = {
		// Clear the overflow counter (OVC) bits in Status Register 0 (ST0).
	}

// DOC: page 472
op zapa()
	syntax = "ZAPA"
	image = "0101 0110 0011 0011"
	action = {
		// ACC = 0;
		// P = 0;
		// OVC = 0;
	}
