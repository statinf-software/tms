/*
 *	TMS Instruction Set
 *
 *	This file is part of GLISS
 *	Copyright (c) 2017, IRIT UPS.
 *
 *	GLISS is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	GLISS is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with GLISS; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

include "nmp/config.nmp"
include "nmp/state.nmp"
include "nmp/macros.nmp"

// GLISS configuration
let proc = "tms"
let bit_order = "uppermost"
let gliss_isize = "16,32"
//let bit_image_order =  1


// modes

// ASSUMES: AMODE = 0
// DOC: Table 5-1. Addressing Modes for “loc16” or “loc32”, page 81
mode LOC32(reg32: loc32index) = reg32
	isloc32 = 1 // TODO: determine this, loc16 is broken for now (duplicate mode into LOC16 most likely)
	num = reg32
	reg32ff = reg32<0..7> // flipped reg32
	syntax =
		// TODO: check bit order of constants
		switch(reg32ff<0..1>) {
			case 0b00:
				// UNTESTED
				format("@0x%x", reg32ff<2..7>)
			case 0b01:
				// UNTESTED
				format("*−SP[%d]", reg32ff<2..7>)
			case 0b11:
				// UNTESTED
				format("*+XAR%d[%d]", reg32ff<5..7>, reg32ff<2..4>)				
			case 0b10:
				// UNTESTED
				if reg32ff<2..2> == 0 then // 0b100
					switch(reg32ff<3..4>) {
						case 0b00: format("*XAR%d++", reg32ff<5..7>)
						case 0b01: format("*−−XAR%d", reg32ff<5..7>)
						case 0b10: format("*+XAR%d[AR0]", reg32ff<5..7>)
						case 0b11: format("*+XAR%d[AR1]", reg32ff<5..7>)
					}
				else // 0b101
					// UNTESTED except *SP++
					switch(reg32) {
						// Stack Addressing Modes (SP):
						case 0b10111101: "*SP++"
						case 0b10111110: "*--SP"
						// C2xLP Indirect Addressing Modes (ARP, XAR0 to XAR7):
						case 0b10111000: "*"
						case 0b10111001: "*++"
						case 0b10111010: "*−−"
						case 0b10111011: "*0++"
						case 0b10111100: "*0−−"
						case 0b10101110: "*BR0++"
						case 0b10101111: "*BR0−−"
						// Circular Indirect Addressing Modes (XAR6, XAR1):
						case 0b10111111: "*AR6%%++"
						default:
							// case 0b10110RRR: "*,ARP%d"
							if reg32ff<0..4> == 0b10110 then
								format("*,ARP%d", reg32ff<5..7>)
							else
								// 32-bit mode
								if isloc32 then
									// case 0b10100AAA: "@XAR%d"
									if reg32ff<0..4> == 0b10100 then
										format("XAR%d", reg32ff<5..7>)
									else switch(reg32) {
										// 32-Bit Register Addressing Modes (XAR0 to XAR7, ACC, P, XT):
										case 0b10101001: "ACC"
										case 0b10101011: "P"
										case 0b10101100: "XT"
										default: "!!!"
									}
									endif
								else // loc16 case
									// case 0b10100AAA: "AR%d"
									if reg32ff<0..4> == 0b10100 then
										format("AR%d", reg32ff<5..7>)
									else switch(reg32) {
										// 16-Bit Register Addressing Modes (AR0 to AR7, AH, AL, PH, PL, TH, SP):
										case 0b10101000: "AH"
										case 0b10101001: "AL"
										case 0b10101010: "PH"
										case 0b10101011: "PL"
										case 0b10101100: "TH"
										case 0b10101101: "SP"
										default: "!!!"
									}
									endif
								endif
							endif
							// default case end
						// switch case end
					}
				endif
		}
	image = format("%8b", reg32)

mode reg_r (r: rindex) = r
	num = r
	syntax =
		switch ( r ) {
		case  0:	"zero"
		case  1:	"ra"
		case  2: 	"sp"
		case  3: 	"gp"
		case  4: 	"tp"
		case  5: 	"t0"
		case  6: 	"t1"
		case  7: 	"t2"
		case  8:	"fp"
		case  9:	"s1"
		case 10:	"a0"
		case 11:	"a1"
		case 12:	"a2"
		case 13:	"a3"
		case 14:	"a4"
		case 15:	"a5"
		}
	image  = format ( "%4b", r )

mode reg_t (r: index) = r
	num = r
	syntax =
		switch ( r ) {
		case  0:	"zero"
		case  1:	"ra"
		case  2: 	"sp"
		case  3: 	"gp"
		case  4: 	"tp"
		case  5: 	"t0"
		case  6: 	"t1"
		case  7: 	"t2"
		case  8:	"fp"
		case  9:	"s1"
		case 10:	"a0"
		case 11:	"a1"
		case 12:	"a2"
		case 13:	"a3"
		case 14:	"a4"
		case 15:	"a5"
		case 16:	"a6"
		case 17:	"a7"
		case 18:	"s2"
		case 19:	"s3"
		case 20:	"s4"
		case 21:	"s5"
		case 22:	"s6"
		case 23:	"s7"
		case 24:	"s8"
		case 25:	"s9"
		case 26:	"s10"
		case 27:	"s11"
		case 28:	"t3"
		case 29:	"t4"
		case 30:	"t5"
		case 31:	"t6"
		}
	image  = format ( "%5b", r )
macro setR(d, v) = if d != 0 then R[d] = v; endif 

mode freg_t (f: index) = f
	num = f
	syntax =
		switch ( f ) {
		case  0:	"f0"
		case  1:	"f1"
		case  2: 	"f2"
		case  3: 	"f3"
		case  4: 	"f4"
		case  5: 	"f5"
		case  6: 	"f6"
		case  7: 	"f7"
		case  8:	"f8"
		case  9:	"f9"
		case 10:	"f10"
		case 11:	"f11"
		case 12:	"f12"
		case 13:	"f13"
		case 14:	"f14"
		case 15:	"f15"
		case 16:	"f16"
		case 17:	"f17"
		case 18:	"f18"
		case 19:	"f19"
		case 20:	"f20"
		case 21:	"f21"
		case 22:	"f22"
		case 23:	"f23"
		case 24:	"f24"
		case 25:	"f25"
		case 26:	"f26"
		case 27:	"f27"
		case 28:	"f28"
		case 29:	"f29"
		case 30:	"f30"
		case 31:	"f31"
		}
	image  = format ( "%5b", f )



mode IMM16(n: half) = n
	syntax = format("#%d", n)
	image = format("%16b", n)

mode UIMM16(n: uhalf) = n
   syntax = format ( "#%d", n )
   image  = format ( "%16b", n )



// top-level instructions
op instruction (x: allinstr)
	syntax = x.syntax
	image = x.image
	action = {
		NPC = PC + 4;
		x.action;
		PC = NPC;
	}
// op TMS16_instr =
op allinstr =
	all_movl
//	| all_rri
//	| all_alu
//	| all_branch
//	| all_special
//	| all_muldiv
//	| all_dshift
//	| all_load
//	| all_stores
//	| all_floating
//	| all_atomic
//	| rv64im

op init ()
	action = {
		R[0] = 0;
	}

include "nmp/alu.nmp"
include "nmp/control.nmp"
include "nmp/special.nmp"
include "nmp/mem.nmp"
include "nmp/floatingpoint.nmp"