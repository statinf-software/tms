/* Generated by gep (123/03/06 23:19:57) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <tms/mem.h>
#include <tms/fetch.h>
#include <tms/gen_int.h>
#include <tms/macros.h>
#include "fetch_table.h"

#define tms_error(e) fprintf(stderr, "%s\n", (e))


/**
 * Halt the fetch module.
 */
static void halt_fetch(void) {
}

/**
 * Initialize the fetch module.
 */
static void init_fetch(void) {
}



/**
 *  initialization and destruction of tms_fetch_t object
 */
static int number_of_fetch_objects = 0;


/**
 * Initialize a fetch handler.
 * @param pf	Current platform.
 * */
tms_fetch_t *tms_new_fetch(tms_platform_t *pf)
{
	tms_fetch_t *res = malloc(sizeof(tms_fetch_t));
	if (res == NULL)
		tms_error("not enough memory to create a tms_fetch_t object"); /* I assume error handling will remain the same, we use tms_error instead of iss_error ? */
	res->mem = tms_get_memory(pf, TMS_MAIN_MEMORY);
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}


/**
 * Delete the given fetch handler.
 * @param fetch		Fetch handler to delete.
 */
void tms_delete_fetch(tms_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		tms_error("cannot delete an NULL tms_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}


/**
 * Fetch and decode an instruction (for CISC instruction set).
 * @param fetch		Fetch handler.
 * @param address	Address of instruction to fetch.
 * @param code		Bytes to store instruction word in.
 * @return			Index of the fetched instruction.
 */
tms_ident_t tms_fetch(tms_fetch_t *fetch, tms_address_t address, mask_t *code) {
	uint32_t value;
	Table_Decodage_CISC *ptr;
	Table_Decodage_CISC *ptr2 =tms_table;

	do {
		
		/* if inst buffer has not enough bits to apply mask, read and add what's needed, read a 32 bit chunk (like in mask_t) at a time */
		while (get_mask_length(code) < get_mask_length(ptr2->mask)) {
			uint8_t buff[4];
			uint32_t word;
			tms_mem_read(fetch->mem, (address + (get_mask_length(code) >> 3)) * 2, buff, 4);
#			ifdef TMS_ORDER_BYTES_CISC
				TMS_ORDER_BYTES_CISC;
#			elif HOST_ENDIANNESS == TARGET_ENDIANNESS
				word = (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | buff[3];
#			endif
			set_mask_chunk(code, get_mask_length(code) >> 5, word);
			set_mask_length(code, get_mask_length(code) + 32);
		}

		/* compute value on mask */
		value = value_on_mask(code, ptr2->mask);
                ptr  = ptr2;
		ptr2 = ptr->table[value].ptr;

	} while (ptr->table[value].type == TABLEFETCH);

	return (tms_ident_t)ptr->table[value].ptr;
}



